using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Editing;

namespace TestsGenerator
{
    public class TestClassGenerator
    {
        SyntaxGenerator generator;

        SyntaxNode generateInitializingMethod(ConstructorDeclarationSyntax constructor)
        {
            List<SyntaxNode> methodBody = new List<SyntaxNode>();
            foreach(ParameterSyntax parameter in constructor.ParameterList.Parameters)
            {
                methodBody.Add(generator.LocalDeclarationStatement(parameter.Type, 
                    parameter.Identifier.ValueText, generator.DefaultExpression(parameter.Type)));
            }
            SyntaxNode statement = generator.AssignmentStatement(
                generator.IdentifierName("testObject"),
                    generator.ObjectCreationExpression(generator.IdentifierName(constructor.Identifier.ValueText), new SyntaxNode[] { }));
            SyntaxNode attributeInitilize = generator.Attribute("TestInitialize", null);
        //    statement = generator.AddAttributes(statement, new SyntaxNode[] { attributeInitilize });
            methodBody.Add(statement);
            SyntaxNode result = generator.MethodDeclaration("Initialize", 
                accessibility: Accessibility.Public, statements: methodBody);
            result = generator.AddAttributes(result, new SyntaxNode[] { attributeInitilize });
            return result;
        }

        List<SyntaxNode> generateArrangeSection(MethodDeclarationSyntax method)
        {
            List<SyntaxNode> result = new List<SyntaxNode>();
            ParameterListSyntax parameters = method.ParameterList;
            foreach(ParameterSyntax parameter in parameters.Parameters)
            {
                var statement = generator.LocalDeclarationStatement(parameter.Type, 
                    parameter.Identifier.ValueText, generator.DefaultExpression(parameter.Type));
                result.Add(statement);
            }
            return result;
        }

        List<SyntaxNode> generateActSection(MethodDeclarationSyntax method)
        {
            List<SyntaxNode> result = new List<SyntaxNode>();
            List<SyntaxNode> parameters = new List<SyntaxNode>();
            foreach(var parameter in method.ParameterList.Parameters)
            {
                parameters.Add(generator.IdentifierName(parameter.Identifier.ValueText));
            }
            var statement = generator.LocalDeclarationStatement( "actual",
               generator.InvocationExpression(
                    generator.MemberAccessExpression(generator.IdentifierName("testObject"), method.Identifier.ValueText),
                    parameters
                )
            );
            result.Add(statement);
            return result;
        }

        List<SyntaxNode> generateAssertSection()
        {
            List<SyntaxNode> result = new List<SyntaxNode>();
            SyntaxNode statement =
                generator.LocalDeclarationStatement(
                    "expected",
                    generator.LiteralExpression(0));
            result.Add(statement);
            statement = generator.ExpressionStatement(
                generator.InvocationExpression(
                    generator.MemberAccessExpression(generator.IdentifierName("Assert"), generator.IdentifierName("AreEqual")),
                    new SyntaxNode[] { generator.IdentifierName("actual"), generator.IdentifierName("expected") }
                    )
                );
            result.Add(statement);
            statement = generator.ExpressionStatement(
                    generator.InvocationExpression(
                        generator.MemberAccessExpression(generator.IdentifierName("Assert"), generator.IdentifierName("Fail")),
                        new SyntaxNode[] { generator.LiteralExpression("autogenerated") }
                    )
                );
            result.Add(statement);
            return result;
        }

        List<SyntaxNode> generateVoidActSection(MethodDeclarationSyntax method)
        {
            List<SyntaxNode> result = new List<SyntaxNode>();
            List<SyntaxNode> parameters = new List<SyntaxNode>();
            foreach (var parameter in method.ParameterList.Parameters)
            {
                parameters.Add(generator.IdentifierName(parameter.Identifier.ValueText));
            }
            var statement = generator.ExpressionStatement(
                generator.InvocationExpression(
                    generator.MemberAccessExpression(
                        generator.IdentifierName("testObject"), method.Identifier.ValueText), 
                        parameters
                    )
                );
            result.Add(statement);
            return result;
        }

        List<SyntaxNode> generateVoidAssertSection()
        {
            List<SyntaxNode> result = new List<SyntaxNode>();
            var statement = generator.ExpressionStatement(
                generator.InvocationExpression(
                    generator.MemberAccessExpression(generator.IdentifierName("Assert"), generator.IdentifierName("Fail")),
                    new SyntaxNode[] { generator.LiteralExpression("autogenerated") }
                )
            );
            result.Add(statement);
            return result;
        }

        public string GenerateClass(string source)
        {
            SyntaxTree tree = CSharpSyntaxTree.ParseText(source);
            CompilationUnitSyntax root = tree.GetCompilationUnitRoot();
            var collector = new TestGenerationCollector();
            collector.Visit(root);

            AdhocWorkspace workspace = null;
            workspace = new AdhocWorkspace();
            generator = SyntaxGenerator.GetGenerator(workspace, LanguageNames.CSharp);
            var usingDirectives = new SyntaxNode[]
            {
                generator.NamespaceImportDeclaration("System"),
                generator.NamespaceImportDeclaration("Microsoft.VisualStudio.TestTools.UnitTesting"),
                generator.NamespaceImportDeclaration(collector.NamespaceNode.Name.ToString())
            };

            SyntaxNode fieldTestObject = 
                generator.FieldDeclaration("testObject", generator.IdentifierName(collector.ClassNode.Identifier.ValueText));

            SyntaxNode methodAttribute = generator.Attribute("TestMethod", null);
            List<SyntaxNode> methodesNodes = new List<SyntaxNode>();
            if (collector.ConstructorNode != null)
                methodesNodes.Add(generateInitializingMethod(collector.ConstructorNode));
          //  else
            //    methodesNodes.Add(generateInitializingMethod(generator.));
            foreach(var method in collector.Nodes)
            {
                var methodBody = generateArrangeSection(method);
                if (method.ReturnType.ToString() == "void")
                {
                    methodBody.AddRange(generateVoidActSection(method));
                    methodBody.AddRange(generateVoidAssertSection());
                }
                else
                {
                    methodBody.AddRange(generateActSection(method));
                    methodBody.AddRange(generateAssertSection());
                }
                SyntaxNode methodDeclaration = generator.MethodDeclaration($"{method.Identifier.ValueText}Test", 
                    accessibility: Accessibility.Public, statements: methodBody);
                methodDeclaration = generator.AddAttributes(methodDeclaration, new SyntaxNode[] { methodAttribute });
                methodesNodes.Add(methodDeclaration);
            }

            SyntaxNode classAttribute = generator.Attribute("TestClass", null);
            List<SyntaxNode> members = new List<SyntaxNode>();
            members.Add(fieldTestObject);
            members.AddRange(methodesNodes);
            SyntaxNode testClass = generator.ClassDeclaration($"{collector.ClassNode.Identifier.ValueText}Test",
                accessibility: Accessibility.Public, members: members);
            testClass = generator.AddAttributes(testClass, new SyntaxNode[] { classAttribute });
            SyntaxNode namespaceDeclararion = generator.NamespaceDeclaration("MyTestClass", testClass);
            var declarations = new List<SyntaxNode>(usingDirectives);
            declarations.Add(namespaceDeclararion);
            SyntaxNode compilationUnit = generator.CompilationUnit(declarations).NormalizeWhitespace();
            Console.WriteLine(compilationUnit.ToString());
            return compilationUnit.ToString(); 
        }

        public Task<string> GenerateTestAsync(string source)
        {
            Task<string> task = new Task<string>(() => GenerateClass(source));
            task.Start();
            return task;
        }

    }
}
